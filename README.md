# Design Patterns



## Índice

- [Sobre](#sobre)
- [Padrões Implementados](#padrões-implementados)
- [Como Usar](#como-usar)
- [Tecnologias Utilizadas](#tecnologias-utilizadas)
- [Contribuição](#contribuição)
- [Licença](#licença)
- [Contato](#contato)

## Sobre

Este repositório contém implementações de diversos padrões de design em Java. O objetivo é fornecer exemplos práticos e compreensíveis para ajudar desenvolvedores a entender e aplicar esses padrões em seus projetos. Cada padrão é acompanhado de uma explicação teórica e um exemplo prático.

## Padrões Implementados

- **Singleton**: Garante que uma classe tenha apenas uma instância e fornece um ponto global de acesso a ela.
- **Factory**: Define uma interface para criar um objeto, mas deixa as subclasses decidirem qual classe instanciar.
- **Abstract Factory**: Fornece uma interface para criar famílias de objetos relacionados ou dependentes sem especificar suas classes concretas.
- **Builder**: Separa a construção de um objeto complexo da sua representação, permitindo que o mesmo processo de construção crie diferentes representações.
- **Prototype**: Permite a criação de novos objetos a partir de um protótipo existente, clonando-o.
- **Adapter**: Permite que a interface de uma classe existente seja usada como outra interface.
- **Bridge**: Desacopla uma abstração da sua implementação, permitindo que ambas variem independentemente.
- **Composite**: Compõe objetos em estruturas de árvore para representar hierarquias parte-todo.
- **Decorator**: Adiciona responsabilidades a um objeto dinamicamente.
- **Facade**: Fornece uma interface simplificada para um subsistema complexo.
- **Flyweight**: Usa o compartilhamento para suportar grandes quantidades de objetos de forma eficiente.
- **Proxy**: Fornece um substituto ou marcador para outro objeto para controlar o acesso a ele.
- **Chain of Responsibility**: Passa uma solicitação ao longo de uma cadeia de manipuladores.
- **Command**: Encapsula uma solicitação como um objeto, permitindo parametrizar clientes com diferentes solicitações.
- **Interpreter**: Define uma gramática para uma linguagem e um interpretador que usa a gramática para interpretar sentenças dessa linguagem.
- **Iterator**: Fornece uma maneira de acessar os elementos de um agregado sequencialmente sem expor sua representação subjacente.
- **Mediator**: Define um objeto que encapsula como um conjunto de objetos interage.
- **Memento**: Captura e externaliza o estado interno de um objeto sem violar o encapsulamento.
- **Observer**: Define uma dependência um-para-muitos entre objetos para que quando um objeto muda de estado, todos os seus dependentes sejam notificados e atualizados automaticamente.
- **State**: Permite que um objeto altere seu comportamento quando seu estado interno muda.
- **Strategy**: Define uma família de algoritmos, encapsula cada um deles e os torna intercambiáveis.
- **Template Method**: Define o esqueleto de um algoritmo em uma operação, deixando alguns passos para as subclasses.
- **Visitor**: Representa uma operação a ser realizada nos elementos de uma estrutura de objeto.

## Como Usar

1. Clone o repositório:
   ```bash
   git clone https://github.com/rodolfod2r2/design-patterns.git
   ```
2. Navegue até o diretório do projeto:
   ```bash
   cd design-patterns
   ```
3. Compile e execute os exemplos:
   ```bash
   javac src/com/example/*.java
   java com.example.Main
   ```

## Tecnologias Utilizadas

- **Java 11**
- **JUnit 5**

## Contribuição

Contribuições são bem-vindas! Sinta-se à vontade para abrir issues e pull requests. Para maiores detalhes, consulte o arquivo [CONTRIBUTING.md](CONTRIBUTING.md).

## Licença

Este projeto está licenciado sob a Licença MIT - veja o arquivo [LICENSE](LICENSE) para mais detalhes.

## Contato

Rodolfo D2R2 - [@rodolfod2r2](https://twitter.com/rodolfod2r2) - rodolfo@example.com

---

Espero que isso ajude! Se precisar de mais alguma coisa ou tiver outras sugestões, estou à disposição.
